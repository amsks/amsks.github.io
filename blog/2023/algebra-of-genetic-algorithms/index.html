<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Algebra of Genetic Algorithms | Aditya Mohan</title> <meta name="author" content="Aditya Mohan"> <meta name="description" content="Hello, Hello, Hello! We are gathered here today to get through this thing called life. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://amsks.github.io/blog/2023/algebra-of-genetic-algorithms/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="//"><span class="font-weight-bold">Aditya </span>Mohan</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">bonjour!</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching and theses</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Algebra of Genetic Algorithms</h1> <p class="post-meta">July 8, 2023</p> <p class="post-tags"> <a href="//blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="//blog/category/evolutionary-computation"> <i class="fas fa-tag fa-sm"></i> evolutionary-computation</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="formalizing-genetic-algorithm-search">Formalizing genetic Algorithm Search</h2> <p>To formalize genetic algorithms we need to define inputs and outputs and formalize what this algorithm does through maps. So, let’s consider \(X\) to be the space of all solutions. From elements of this space of solutions, we can construct multisets by grouping them, so let’s take \(P_M(X)\) to be this maximal set of multi-sets. Thus, a population \(P\) can be thought of as one of these possible multisets and so</p> \[P \in P_M(X)\] <p>Now, the process of mutation and cross-over can be formalized as a genetic operator that maps \(P_M(X)\), which can also be thought of as mapping \(X^k\) to \(X\). Let \(\Omega\) be a genetic operator. Thus, we can say:</p> \[\Omega:P_M(X) \rightarrow P_M(X) \\ \Omega : X^k \rightarrow X \,\,\,\, \,\,\,\,\forall k \in \mathbb{N} \\ \implies \Omega (x_1, ..., x_k \in X) = x \in X\] <p>Thus, we can now classify the operators as follows:</p> <ul> <li>Recombination → \(\Omega : X^2 \rightarrow X\)</li> <li>Mutation → \(\Omega : X \rightarrow X\)</li> <li>Selection → \(\Omega: A \subseteq P_M(X) \rightarrow B \subseteq A\)</li> </ul> <h2 id="forma-analysis">Forma Analysis</h2> <h3 id="schema-theorem">Schema Theorem</h3> <p>Forma analysis creates a rigorous framework to look at how genetic algorithms might work on different problems and comes from Schema Theorem. According to the original paper, the Schema Theorem can be essentially summarized as</p> \[\mathbb{E} \{N_\xi(t+1) \} \geq N_\xi(t) \frac{\hat{\mu}_\xi(t)}{\bar{\mu}(t)} \bigg[ 1 - \sum_{\omega \in \Omega}p_\omega p_\omega ^\xi\bigg]\] <p>The various elements in this equation are:</p> <ul> <li>\(\xi\) → Schema which is like a template of strings in which certain positions are fixed. For example, a schema for binary strings like 1XX0X1 means that the first, fourth, and sixth positions have to be 1, 0, and 1, respectively, and the other positions can be either 0 or 1</li> <li>\(N_\xi(t)\) → Population size at time \(t\) that belongs to a schema \(\xi\)</li> <li>\(\hat{\mu}_\xi(t)\) → Average fitness of all the members of the population at time t that are instances (members) of the schema \(\xi\)</li> <li>\(\bar{\mu}(t)\) → average fitness of the whole population at time t</li> <li>\(\Omega\) → Set of genetic operators in Use</li> <li>\(p_\omega p_\omega ^\xi\) → This signified the potentially disruptive effect when we apply the operators \(\omega \in \Omega\) to members of schema \(\xi\)</li> </ul> <p>The theorem is saying that the expectation of the next generation under a schema is proportional to the relative fitness of the schema and inversely to the disruptive potential of the genetic operators on this schema. This disruptive potential is directly proportional to the length of the schema, in addition to the probability of other operators like mutation and crossover. Thus, short and low-order schemata with above-average fitness increase exponentially in frequency in successive generations. The ability of the schema theorem, which governs the behavior of a simple genetic algorithm, to lead the search to interesting areas of the space is governed by the quality of the information it collects about the space through observed schema fitness averages in the population → If the schemata tend to collect together solutions with related performance, then the fitness-variance of schemata will be relatively low, and the information that the schema theorem utilizes will have predictive power for previously untested instances of schemata that the algorithm may generate. On the other hand, if the performances are not related in the schemata then the solutions generated cannot be assumed to bear any relation to the fitness of the parents i.e they might just be random. Thus, we need to incorporate domain-specific knowledge in the representations that we use for our algorithm since that signified the underlying distribution that might relate to similar performances in the future. Now, it was proven in the 1990s that this schema theorem applied to any subset of the schema \(\xi\), and not just the whole schemata, under the constraint that we adjust the disruptive potential according to the subset. The generalized schema was termed Formae (Singular Forma) and this is how the theory around format came to be. Forma analysis allows us to develop genetic representations and operators that can maximize \(\hat{\mu_\xi(t)}\) by selecting subsets of \(\xi\) that are appropriate for the domain. This is done by constructing equivalence relations that partition the search space into appropriate equivalence classes which play the rôle of format.</p> <h3 id="equivalence-relations--basis">Equivalence Relations → Basis</h3> <p>The first step to forma analysis is to define relations (\(\sim\) ) on our search space \(X\). This is simply saying that each element of our search space can have a property that is either true or false. For example, we can define a greater than relation \(&gt; : X \rightarrow \{0,1\}\) that compares our element to some integer. Now, these relations are called equivalence relations if they are</p> <ul> <li>Reflexive → If each element of the domain is related to itself</li> <li>Symmetric → \(a \sim b \implies b \sim a\)</li> <li>Transitive → \(a \sim b , b \sim c \implies a \sim c\)</li> </ul> <p>Equivalence relations are essentially partitions of \(X\) since they partition it into equivalence classes. Going back to our example of a schema, if we are to consider our binary schema 1XX0X1 and generalize it to something like XXXXXX where X represents positions in a string that need to be specified and X represents the unspecified positions, then the equivalence relation here is that the 1, 4 and 6 positions need to be specified. Now, taking \(\{0,1\}\) as our alphabet one of the equivalence classes that are induced by this equivalence relation is 1XX0X1, but there can be others like 0XX0X1, or 1XX0X0. Thus, our equivalence relation induces multiple equivalence classes that then form the schema.</p> <p>Let us denote the set of all equivalence relations on \(X\) as \(E(X)\) . So, if we have an equivalence relation \(\psi \in E(X)\), then we can call \(E_\psi\) to be the set of equivalence classes induced by \(\psi\). This set of classes is called formae. Now, if we have a vector of relations, say \(\mathbf{\Psi} \in E(X)\) , then we call \(\Xi_\mathbf{\Psi}\) as the set of formae, given by:</p> \[\Xi_\mathbf{\Psi} := \prod_{i=1}^\mathbf{\Psi} \Xi_{\psi_i}\] <p>And we can also denote the union of the formae as</p> \[\Xi(\mathbf{\Psi}) := \bigcup_{\psi \in \mathbf{\Psi}} \Xi_\psi\] <p>Now, let’s consider a relation that lies at the intersection of all the members of \(\mathbf{\Psi}\) → \(\phi := \bigcap \mathbf{\Psi}\). This relation would induce equivalence classes that would be intersections of the classes induced by the elements of \(\mathbf{\Psi}\), and this result can be mathematically written as:</p> \[[x]_\phi = \bigcap \{ [x]_\psi \,\, |\,\, \psi \in \mathbf{\Psi} \}\] <p>We can also define the span of \(E(X)\) as a map from its power set onto itself</p> \[Span: \mathbb{P}(E(X)) \rightarrow \mathbb{P}(E(X))\] <table> <tbody> <tr> <td>If we have a condition where a set of relations \(B \in E(X)\) has members that cannot be constructed by intersecting any other members of \(B\), then \(B\) is called an independent set of relations. Also, \(B\) is said to be orthogonal to the order \(k\) if given any \(k\) equivalence classes induced by members of \(B\), their intersection is non-empty. If $$k =</td> <td>B</td> <td>\(, then we call\)B\(orthogonal. It has been shown that orthogonality implies independence, and so, we can use this concept to define a basis of\)\mathbf{\Psi}\(→ Any subset\)B\(of\)\mathbf{\Psi} \subseteq E(X)$$ will constitute a basis iff:</td> </tr> </tbody> </table> <ul> <li>\(B\) in independent</li> <li>\(B\) spans \(\mathbf{\Psi}\)</li> </ul> <p>Thus, if \(B\) is orthogonal then we have an orthogonal basis. Moreover, the number of elements in \(B\) determines the dimensions of our basis. This notion of orthogonality of the set is important as it helps us ensure that our mapping from representations to solutions is fully defined.</p> <h3 id="representations-through-basis">Representations through Basis</h3> <p>Once we have a basis, we can follow the vectorization procedure to vectorize \(\mathbf{\Psi}\) in terms of the elements of \(B\) → A general equivalence relation \(\mathbf{\Psi}\) can be decomposed into component basic equivalence relations in \(B\). Our first step would be to go from equivalence relations to representations, by defining a representation. We first define a partial representation function \(\rho\) for an equivalence relation \(b \in E(X)\):</p> \[\rho_{b} : X \rightarrow \Xi_b\] <p>Taking \([x]_b\) to be the equivalence class under the relation \(b,\) we can say</p> \[\rho_b(x) := [x]_b\] <p>Thus, if we have a set \(B = \{ b_1, b_2, ..., b_n\}\), we can define a genetic representation function as</p> \[\mathbf{\rho_B} := (\rho_{b_1}, ..., \rho_{b_2}) \,\,\,\,\, s.t \,\,\,\,\, \mathbf{\rho_B}: X \rightarrow \Xi_B \\ \implies \mathbf{\rho_B} (x) = ([x]_{b_1}, ..., [x]_{b_n})\] <p>Let \(C\) be the space of chromosomes (Representations), we can call this set the image of \(X\)under \(\mathbf{\rho_B}\) and if \(\mathbf{\rho}_B\) is injective, we can define a growth function \(g:C \rightarrow X\) as the inverse of the representation function:</p> \[g: \Xi_b \rightarrow X \\ g(\mathbf{\xi}) := \mathbf{\rho}_B^{-1}(\mathbf{\xi})\] <p>We now have a vector space over which we have created a way to map representations to Chromosomes and back, which allow us to define genetic operations through these functions.</p> <h3 id="coverage-and-unique-basis">Coverage and Unique Basis</h3> <p>Our next step is to understand how these equivalence relations can generate representations, and how the Chromosomes relate to these equivalence relations. To go towards usefulness, we first have to define something called Coverage → A set of equivalence relations \(\mathbf{\Psi} \subset E(X)\) is said to cover \(X\) if, for each pair of solutions in \(X\), there is at least one equivalence relation in \(\mathbf{\Psi}\) under which the solutions in the pair are not equivalent. Formally,</p> \[\forall x \in X, y \in X/\{x\} : \exists \psi \in \mathbf{\Psi} : \psi(x,y) = 0\] <p>The significance of this notion is easy to understand → Coverage is important because if a set of equivalence relations covers \(X\) then specifying to which equivalence class a solution belongs for each of the equivalence relations in the set suffices to identify a solution uniquely. By this definition, we can also prove that any basis \(B\) fo \(\mathbf{\Psi}\) would cover \(X\) if it covers \(\mathbf{\Psi}\) and extend it further to show that any orthogonal basis of \(X\) that also covers it can be a faithful representation of \(X\). This is the point that we have been trying to dig-into through formalism → The information that this orthogonal basis includes in its formulation is critical to the impact of genetic algorithm in search.</p> <h3 id="genes-and-alleles">Genes and Alleles</h3> <p>We can define the Genes as the members of the basis \(B\) of \(\mathbf{\Psi}\) and the members of \(\Xi_B\) will be called the formae, or the alleles.</p> <p>Using our basis we can track the information it transmits by checking the equivalence of the solutions generated under the relations in \(B\). This is called the Dynastic Potential → Given a basis \(B\) for a set of relations \(\mathbf{\Psi} \subset E(X)\) that covers \(X\), the dynastic potential \(\Gamma\) of a subset \(L \subseteq X\) is the set of all solutions in \(X\) that are equivalent to at least one member of \(L\) under the equivalence relations in \(B\).</p> \[\Gamma: P(X) \rightarrow P(X) \\ \Gamma(L) := \big \{ x \in X | \,\,\, \forall b \in B : \exists l \subset L: b(l,x) = 1 \big \}\] <p>Thus, the dynastic potential of \(L\) would be the set of all children that can be generated using only alleles available from the parent solutions in L. The solutions in \(L\) belong to different equivalence classes or formae. Thus, by measuring how many formae include solutions in \(L\). This is called the similarity set, formally defined as the intersection of all the formae to which solutions in \(L\) can belong:</p> \[\Sigma(L) := \begin{cases} \bigcap \{ \xi \in \Xi \,\, | \,\, L \subset \xi \}, \,\,\,\, if\,\, \exists \xi \in \Xi: L \subset \xi \\ X, \,\,\,\, otherwise \end{cases}\] <p>Now, it has been proved that the dynastic potential is contained by the similarity set</p> \[\forall L\subset X: \Gamma(L) \subset \Sigma(L)\] <p>Thus, we now have a full mathematical mechanism to se how the optimization process evolves:</p> <ol> <li>We have a representation of genes as our Basis of equivalence relations</li> <li>These genes map to alleles through a vector of partial representations \(\mathbf{\rho}_B\)</li> <li>The chromosomes then evolve to give a new set of genes through the growth function \(g\) after applying genetic operators \(\Omega\) to the representations</li> <li>The information that survives this process is quantified by the dynastic potential \(\Gamma\) of the solution space hence generated.</li> </ol> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2022/displaying-external-posts-on-your-al-folio-blog/">Displaying External Posts on Your al-folio Blog</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2023/policy-gradients/">Policy Gradients</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2023/model-free-control/">Model-Free Control</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2023/model-free-prediction/">Model-Free Prediction</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="//blog/2023/planning-and-dynamic-programming/">Planning and Dynamic Programming</a> </li> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Aditya Mohan. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank"></a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id="></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>